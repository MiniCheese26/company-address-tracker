import {app, BrowserWindow, dialog, ipcMain} from 'electron';
import SQLite from 'better-sqlite3';
import * as fs from 'fs/promises';
import contextMenu from 'electron-context-menu';

contextMenu();

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) { // eslint-disable-line global-require
  app.quit();
}

export type QueryGetArgs = {
  statement: string,
  getArgs?: unknown[],
  responseId?: string
}

export interface QueryResponse<T> {
  data: T,
  responseId?: string
}

export type QueryRunArgs = {
  statement: string,
  runArgs?: unknown[],
  responseId?: string
}

export type BrowseArgs = {
  options: Electron.OpenDialogSyncOptions,
  responseId?: string
}

export type ReadFileArgs = {
  filepath: string,
  responseId?: string
}

export type WriteFileArgs = {
  filepath: string,
  data: string,
  responseId?: string
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
	height: 720,
	width: 1280,
	backgroundColor: '#FFF',
	webPreferences: {
	  nodeIntegration: true,
	  contextIsolation: false
	}
  });

  mainWindow.removeMenu();

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  const database = SQLite('data.sqlite3');

  database.exec(`CREATE TABLE IF NOT EXISTS "addresses"
                 (
                     "id"           INTEGER,
                     "company_name" TEXT    NOT NULL,
                     "city"         TEXT    NOT NULL,
                     "county"       TEXT,
                     "country"      TEXT,
                     "postcode"     TEXT    NOT NULL,
                     "time_added"   INTEGER NOT NULL,
                     PRIMARY KEY ("id" AUTOINCREMENT)
                 )`);

  database.exec(`CREATE TABLE IF NOT EXISTS "address_lines"
                 (
                     "id"           INTEGER,
                     "address_id"   INTEGER,
                     "address_line" TEXT NOT NULL,
                     FOREIGN KEY ("address_id") REFERENCES "addresses" ("id"),
                     PRIMARY KEY ("id" AUTOINCREMENT)
                 )`);

  ipcMain.on('to-query-run', (event, args: QueryRunArgs) => {
	const stmt = database.prepare(args.statement);

	event.reply('from-query-run', {data: stmt.run(args.runArgs), responseId: args.responseId});
  });

  ipcMain.on('to-query-transaction', (event, args: QueryRunArgs) => {
	const stmt = database.prepare(args.statement);

	const insertMany = database.transaction((addresses: unknown[]) => {
	  addresses.forEach(address => {
		stmt.run(address);
	  });
	});

	event.reply('from-query-transaction', {data: insertMany(args.runArgs), responseId: args.responseId});
  });

  ipcMain.on('to-query-get', (event, args: QueryGetArgs) => {
	const stmt = database.prepare(args.statement);

	event.reply('from-query-get', {data: stmt.get(args.getArgs), responseId: args.responseId});
  });

  ipcMain.on('to-query-get-all', (event, args: QueryGetArgs) => {
	const stmt = database.prepare(args.statement);

	event.reply('from-query-get-all', {data: stmt.all(args.getArgs), responseId: args.responseId});
  });

  ipcMain.on('to-browse', async (event, args: BrowseArgs) => {
	const file = await dialog.showOpenDialog(new BrowserWindow({
	  show: false,
	  alwaysOnTop: true
	}), args.options);

	event.reply('from-browse', {data: file, responseId: args.responseId});
  });

  ipcMain.on('to-read-file', async (event, args: ReadFileArgs) => {
	let data;

	try {
	  data = await fs.readFile(args.filepath, 'utf-8');
	} catch (e) {
	  event.reply('from-read-file', {data: e, responseId: args.responseId, isError: true});
	  return;
	}

	event.reply('from-read-file', {data, responseId: args.responseId});
  });

  ipcMain.on('to-read-file-sync', async (event, args: ReadFileArgs) => {
	let data;

	try {
	  data = await fs.readFile(args.filepath, 'utf-8');
	} catch (e) {
	  event.returnValue = {data: e, isError: true};
	  return;
	}

	event.returnValue = {data};
  });

  ipcMain.on('to-write-file', async (event, args: WriteFileArgs) => {
	try {
	  await fs.writeFile(args.filepath, args.data);
	} catch (e) {
	  event.reply('from-write-file', {data: false, responseId: args.responseId});
	  return;
	}

	event.reply('from-write-file', {data: true, responseId: args.responseId});
  });

  ipcMain.on('to-write-file-sync', async (event, args: WriteFileArgs) => {
	try {
	  await fs.writeFile(args.filepath, args.data);
	} catch (e) {
	  event.returnValue = {data: e, isError: true};
	  return;
	}

	event.returnValue = {data: true};
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
	app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
	createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

