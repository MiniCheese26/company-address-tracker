import {app, autoUpdater, BrowserWindow, ipcMain} from 'electron';
import * as fs from 'fs/promises';
import contextMenu from 'electron-context-menu';
import {QueryResult} from 'pg';

const { Pool} = require('pg');

contextMenu();

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) { // eslint-disable-line global-require
  app.quit();
}

export type ReadFileArgs = {
  filepath: string,
  responseId?: string
}

export type WriteFileArgs = {
  filepath: string,
  data: string,
  responseId?: string
}

export type PostgresQueryArgs = {
  query: string,
  args?: unknown[]
}

export type PostgresTransactionArgs = {
  query: string,
  args: unknown[][]
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
	height: 720,
	width: 1280,
	backgroundColor: '#FFF',
	webPreferences: {
	  nodeIntegration: true,
	  contextIsolation: false
	}
  });

  //mainWindow.removeMenu();

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  const poolConfig = new Pool({
	user: 'user',
	host: 'ec2-18-168-226-3.eu-west-2.compute.amazonaws.com',
	database: 'addresstrackerapp',
	port: 5432,
  });

  ipcMain.handle('to-read-file', async (event, args: ReadFileArgs) => {
	let data;

	try {
	  data = await fs.readFile(args.filepath, 'utf-8');
	} catch (e) {
	  return e;
	}

	return data;
  });

  ipcMain.on('to-read-file-sync', async (event, args: ReadFileArgs) => {
	let data;

	try {
	  data = await fs.readFile(args.filepath, 'utf-8');
	} catch (e) {
	  event.returnValue = {data: e, isError: true};
	  return;
	}

	event.returnValue = {data};
  });

  ipcMain.on('to-write-file', async (event, args: WriteFileArgs) => {
	try {
	  await fs.writeFile(args.filepath, args.data);
	} catch (e) {
	  event.reply('from-write-file', {data: false, responseId: args.responseId});
	  return;
	}

	event.reply('from-write-file', {data: true, responseId: args.responseId});
  });

  ipcMain.on('to-write-file-sync', async (event, args: WriteFileArgs) => {
	try {
	  await fs.writeFile(args.filepath, args.data);
	} catch (e) {
	  event.returnValue = {data: e, isError: true};
	  return;
	}

	event.returnValue = {data: true};
  });

  ipcMain.handle('to-query-postgres', async (event, args: PostgresQueryArgs) => {
    const client = await poolConfig.connect();

    try {
	  const queryResult = await client.query(args.query, args.args);

	  if (queryResult) {
		return {rowCount: queryResult.rowCount, rows: queryResult.rows};
	  }
	} finally {
      client.release();
	}

	return undefined;
  });

  ipcMain.handle('to-transaction-postgres', async (event, args: PostgresTransactionArgs) => {
	const client = await poolConfig.connect();

	const results: QueryResult[] = [];

	for (const x of args.args) {
	  const queryResult = await client.query(args.query, x);
	  results.push(queryResult);
	}

	client.release();

	return results.map(x => ({rowCount: x.rowCount, rows: x.rows}));
  });

  autoUpdater.on('checking-for-update', () => {
    console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!checking');
  });

  autoUpdater.on('update-available', () => {
    console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!available');
  });

  autoUpdater.on('update-not-available', () => {
    console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!not available');
  });

  autoUpdater.on('error', (err) => {
	console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ERROR', err);
  });

  autoUpdater.setFeedURL({
	url: 'https://companyaddresstrackerpseudo.s3.eu-west-2.amazonaws.com/RELEASES/RELEASES'
  });

  autoUpdater.checkForUpdates();

  // Set global temporary directory for things like auto update downloads, creating it if it doesn't exist already.
  /*const tempPath = path.join(app.getPath('temp'), 'NTWRK');
  if (!fsSync.existsSync(tempPath)) fsSync.mkdirSync(tempPath);

  (
	async () => {
	  const releases = await
	}
  )();*/
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
	app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
	createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

